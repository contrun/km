<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on wiki</title><link>https://wiki.cont.run/posts/</link><description>Recent content in Posts on wiki</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://wiki.cont.run/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Chrome download shelf</title><link>https://wiki.cont.run/chrome-download-shelf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/chrome-download-shelf/</guid><description>Chrome download shelf is the widget shown in the buttom when you initiate a new download. This document summarizes how the download shelf is implemented. It is sketchy on the details. For more information, click on the source code or documentation links.
How to inspect chrome browser ui components In short, run chrome with chromium --enable-ui-devtools=1234 and open url chrome://inspect/#native-ui. See also UI DevTools Overview and Chromium Desktop UI Debugging Tools and Tips.</description></item><item><title>debugging systemd units</title><link>https://wiki.cont.run/debugging-systemd-units/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/debugging-systemd-units/</guid><description>A systemd unit failed, and it worked great when you run the command manually. What the fuck happend? The running environment of your systemd services is different from your command line. It can be hard to reproduce.
override units with tmux as ExecStart Say, I need to debug a restic systemd unit. I have set a few environment variables. I need to access some state directory and cache directory. I need to run a few prestart commands.</description></item><item><title>identity-aware proxy</title><link>https://wiki.cont.run/identity-aware-proxy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/identity-aware-proxy/</guid><description>An identity-aware proxy is a reverse proxy which forwards normal payload and attaches the identity information to the backend servers.
Identity-aware proxy is an essential part of Google&amp;rsquo;s beyondcorp.
Beyondcorp To me, there&amp;rsquo;re three key ingredients for beyondcorp.
Collecting all collectible information about the device and user. Proxying all traffic through an access proxy, instead of setting up a trusted perimeter. Specifying security policy through a unified configuration center and a powerful dsl (cel).</description></item><item><title>kernel development with nix</title><link>https://wiki.cont.run/kernel-development-with-nix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/kernel-development-with-nix/</guid><description>See also Kernel Debugging with QEMU.
This nix file should be placed in the root directory of kernel source code.
{ system ? builtins.currentSystem, configuration ? null , nixpkgs ? import &amp;lt;nixpkgs&amp;gt; { }, extraConfigFile ? &amp;#34;config&amp;#34;, ... }@args: with nixpkgs.pkgs; let buildLinuxArgs = builtins.removeAttrs args [ &amp;#34;system&amp;#34; &amp;#34;configuration&amp;#34; &amp;#34;nixpkgs&amp;#34; &amp;#34;extraConfigFile&amp;#34; ]; makeKernelVersion = src: stdenvNoCC.mkDerivation { name = &amp;#34;my-kernel-version&amp;#34;; inherit src; phases = &amp;#34;installPhase&amp;#34;; # make kernelversion also works. installPhase = &amp;#39;&amp;#39; set -x s=&amp;#34;$(&amp;lt; &amp;#34;$src/Makefile&amp;#34;)&amp;#34; get() { awk &amp;#34;/^$1 = / &amp;#34;&amp;#39;{print $3}&amp;#39; &amp;lt;&amp;lt;&amp;lt; &amp;#34;$s&amp;#34; } printf &amp;#39;%s.</description></item><item><title>quine in haskell</title><link>https://wiki.cont.run/quine-in-haskell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/quine-in-haskell/</guid><description>See How to make compressed file quines, step by step
#!/usr/bin/env stack -- stack --resolver lts-15.01 script module Main where import Data.List (intercalate) main :: IO () main = putStr $ (unlines prefix) ++ (getPrefixDef prefix) where getPrefixDef list = (&amp;#34; prefix =\n[\n&amp;#34;) ++ (intercalate &amp;#34;,\n&amp;#34; (map show list)) ++ &amp;#34;\n]&amp;#34; prefix = [ &amp;#34;#!/usr/bin/env stack&amp;#34;, &amp;#34;-- stack --resolver lts-15.01 script&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;module Main where&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;import Data.List (intercalate)&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;main :: IO ()&amp;#34;, &amp;#34;main = putStr $ (unlines prefix) ++ (getPrefixDef prefix) where&amp;#34;, &amp;#34; getPrefixDef list = (\&amp;#34;prefix =\\n [\\n \&amp;#34;) ++ (intercalate \&amp;#34;,\\n \&amp;#34;(map show list)) ++ \&amp;#34;\\n ]\&amp;#34;&amp;#34; ]</description></item><item><title>self-hosted infrastructure</title><link>https://wiki.cont.run/self-hosted-infrastructure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/self-hosted-infrastructure/</guid><description>TLDR: I use tailscale/zerotier to establish a smallish mesh network. I use envoy as an edge router to forward L4 traffic. I mainly provision and manage services with nix, docker and sops. When it is absolutely required, I use k3s to deploy Kubernetes services. Traefik is used for routing, and authelia is used for blocking unauthorized access. To multiplexing protocols with a single port, I use aioproxy. I use restic to back up my inevitably accumulated state.</description></item><item><title>self-hosted services</title><link>https://wiki.cont.run/self-hosted-services/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/self-hosted-services/</guid><description>TODO. For now, See self-hosted infrastructure.</description></item><item><title>sigma bullets</title><link>https://wiki.cont.run/sigma-bullets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/sigma-bullets/</guid><description>Introduction This document summarize how a zero-knowledge confidential transaction scheme works and how to implement it. A confidential transaction scheme is a transaction scheme with which the transaction value and the balance of the sender and receiver are encrypted. The zero-knowledge part means that outsider can effectively learn nothing about the values, although he can verify the transaction is not fabricated. The main references are Bulletproofs and Zether. We use Zether to homomorphically encrypt the transaction value so that the we can directly add/subtract ciphertext of the encrypted balance which can then be decrypted into the correct balance after the transaction.</description></item></channel></rss>
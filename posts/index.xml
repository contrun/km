<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on wiki</title><link>https://wiki.cont.run/posts/</link><description>Recent content in Posts on wiki</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://wiki.cont.run/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>identity-aware proxy</title><link>https://wiki.cont.run/identity-aware-proxy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/identity-aware-proxy/</guid><description>An identity-aware proxy is a reverse proxy which forwards normal payload and attaches the identity information to the backend servers.
Identity-aware proxy is an essential part of Google&amp;rsquo;s beyondcorp.
Beyondcorp To me, there&amp;rsquo;re three key ingredients for beyondcorp.
Collecting all collectible information about the device and user. Proxying all traffic through an access proxy, instead of setting up a trusted perimeter. Specifying security policy through a unified configuration center and a powerful dsl (cel).</description></item><item><title>kernel development with nix</title><link>https://wiki.cont.run/kernel-development-with-nix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/kernel-development-with-nix/</guid><description>See also Kernel Debugging with QEMU.
This nix file should be placed in the root directory of kernel source code.
{ system ? builtins.currentSystem, configuration ? null , nixpkgs ? import &amp;lt;nixpkgs&amp;gt; { }, extraConfigFile ? &amp;#34;config&amp;#34;, ... }@args: with nixpkgs.pkgs; let buildLinuxArgs = builtins.removeAttrs args [ &amp;#34;system&amp;#34; &amp;#34;configuration&amp;#34; &amp;#34;nixpkgs&amp;#34; &amp;#34;extraConfigFile&amp;#34; ]; makeKernelVersion = src: stdenvNoCC.mkDerivation { name = &amp;#34;my-kernel-version&amp;#34;; inherit src; phases = &amp;#34;installPhase&amp;#34;; # make kernelversion also works. installPhase = &amp;#39;&amp;#39; set -x s=&amp;#34;$(&amp;lt; &amp;#34;$src/Makefile&amp;#34;)&amp;#34; get() { awk &amp;#34;/^$1 = / &amp;#34;&amp;#39;{print $3}&amp;#39; &amp;lt;&amp;lt;&amp;lt; &amp;#34;$s&amp;#34; } printf &amp;#39;%s.</description></item><item><title>quine in haskell</title><link>https://wiki.cont.run/quine-in-haskell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/quine-in-haskell/</guid><description>See How to make compressed file quines, step by step
#!/usr/bin/env stack -- stack --resolver lts-15.01 script module Main where import Data.List (intercalate) main :: IO () main = putStr $ (unlines prefix) ++ (getPrefixDef prefix) where getPrefixDef list = (&amp;#34; prefix =\n[\n&amp;#34;) ++ (intercalate &amp;#34;,\n&amp;#34; (map show list)) ++ &amp;#34;\n]&amp;#34; prefix = [ &amp;#34;#!/usr/bin/env stack&amp;#34;, &amp;#34;-- stack --resolver lts-15.01 script&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;module Main where&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;import Data.List (intercalate)&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;main :: IO ()&amp;#34;, &amp;#34;main = putStr $ (unlines prefix) ++ (getPrefixDef prefix) where&amp;#34;, &amp;#34; getPrefixDef list = (\&amp;#34;prefix =\\n [\\n \&amp;#34;) ++ (intercalate \&amp;#34;,\\n \&amp;#34;(map show list)) ++ \&amp;#34;\\n ]\&amp;#34;&amp;#34; ]</description></item><item><title>self-hosted services</title><link>https://wiki.cont.run/self-hosted-services/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/self-hosted-services/</guid><description>TLDR: I use tailscale/zerotier to establish a smallish mesh network. I use envoy as an edge router to forward L4 traffic. I mainly provision and manage services with nix, docker and sops. When it is absolutely required, I use k3s to deploy Kubernetes services. Traefik is used for routing, and authelia is used for blocking unauthorized access. To multiplexing protocols with a single port, I use aioproxy. I use restic to back up my inevitably accumulated state.</description></item><item><title>sigma bullets</title><link>https://wiki.cont.run/sigma-bullets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/sigma-bullets/</guid><description>Introduction This document summarize how a zero-knowledge confidential transaction scheme works and how to implement it. A confidential transaction scheme is a transaction scheme with which the transaction value and the balance of the sender and receiver are encrypted. The zero-knowledge part means that outsider can effectively learn nothing about the values, although he can verify the transaction is not fabricated. The main references are Bulletproofs and Zether. We use Zether to homomorphically encrypt the transaction value so that the we can directly add/subtract ciphertext of the encrypted balance which can then be decrypted into the correct balance after the transaction.</description></item></channel></rss>
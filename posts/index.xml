<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on wiki</title><link>https://wiki.cont.run/posts/</link><description>Recent content in Posts on wiki</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://wiki.cont.run/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>chrome download shelf</title><link>https://wiki.cont.run/chrome-download-shelf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/chrome-download-shelf/</guid><description>Chrome download shelf is the widget shown in the buttom when you initiate a new download. This document summarizes how the download shelf is implemented. It is sketchy on the details. For more information, click on the source code or documentation links.
How to inspect chrome browser ui components In short, run chrome with chromium --enable-ui-devtools=1234 and open url chrome://inspect/#native-ui. See also UI DevTools Overview and Chromium Desktop UI Debugging Tools and Tips.</description></item><item><title>communicating sequential processes</title><link>https://wiki.cont.run/communicating-sequential-processes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/communicating-sequential-processes/</guid><description>This is an unfinished review of the book Communicating Sequential Processes by C. A. R. Hoare.
I&amp;rsquo;d like to quote Dijkstra on how enlightening this book is.
The most profound reason, however, was keenly felt by those who had seen earlier drafts of his manuscript, which shed with surprising clarity new light on what computing science could—or even should—be. To say or feel that the computing scientist’s main challenge is not to get confused by the complexities of his own making is one thing; it is quite a different matter to discover and show how a strict adherence to the tangible and quite explicit elegance of a few mathematical laws can achieve this lofty goal.</description></item><item><title>debugging systemd units</title><link>https://wiki.cont.run/debugging-systemd-units/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/debugging-systemd-units/</guid><description>A systemd unit failed, and it worked great when you run the command manually. What the fuck happend? The running environment of your systemd services is different from your command line. It can be hard to reproduce.
override units with tmux as ExecStart Say, I need to debug a restic systemd unit. I have set a few environment variables. I need to access some state directory and cache directory. I need to run a few prestart commands.</description></item><item><title>embedding bpf objects</title><link>https://wiki.cont.run/embedding-bpf-objects/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/embedding-bpf-objects/</guid><description>Too many open files I had trouble compiling. The nix builder failed with too many open files.
find /proc -maxdepth 1 -type d -name &amp;#39;[0-9]*&amp;#39; \ -exec bash -c &amp;#34;ls {}/fd/ | wc -l | tr &amp;#39;\n&amp;#39; &amp;#39; &amp;#39;&amp;#34; \; \ -printf &amp;#34;fds (PID = %P), command: &amp;#34; \ -exec bash -c &amp;#34;tr &amp;#39;\0&amp;#39; &amp;#39; &amp;#39; &amp;lt; {}/cmdline&amp;#34; \; \ -exec echo \; | sort -rn | head showed systemd consumed more than 700 file descriptors on startup.</description></item><item><title>fuchsia starnix</title><link>https://wiki.cont.run/fuchsia-starnix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/fuchsia-starnix/</guid><description>Starnix is the code name of a Fuchsia project which proposes to run unmodified Linux programs. This is my take to understand what is needed to do in order for Fuchsia to run Linux programs, and how Linux runs programs itself. The main reference is RFC 0082 from Fuchsia, from which you definitely will benefit more.
A Tale of Two Alternatives So, you want to run unmodified Linux programs in Fuchsia.</description></item><item><title>identity-aware proxy</title><link>https://wiki.cont.run/identity-aware-proxy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/identity-aware-proxy/</guid><description>An identity-aware proxy is a reverse proxy which forwards normal payload and attaches the identity information to the backend servers.
Identity-aware proxy is an essential part of Google&amp;rsquo;s beyondcorp.
Beyondcorp To me, there&amp;rsquo;re three key ingredients for beyondcorp.
Collecting all collectible information about the device and user. Proxying all traffic through an access proxy, instead of setting up a trusted perimeter. Specifying security policy through a unified configuration center and a powerful dsl (cel).</description></item><item><title>kernel development with nix</title><link>https://wiki.cont.run/kernel-development-with-nix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/kernel-development-with-nix/</guid><description>See also Kernel Debugging with QEMU.
This nix file should be placed in the root directory of kernel source code.
{ system ? builtins.currentSystem , configuration ? null , nixpkgs ? import { } , extraConfigFile ? &amp;ldquo;config&amp;rdquo; , &amp;hellip; }@args: with nixpkgs.pkgs; let buildLinuxArgs = builtins.removeAttrs args [ &amp;ldquo;system&amp;rdquo; &amp;ldquo;configuration&amp;rdquo; &amp;ldquo;nixpkgs&amp;rdquo; &amp;ldquo;extraConfigFile&amp;rdquo; ];
makeKernelVersion = src: stdenvNoCC.mkDerivation { name = &amp;ldquo;my-kernel-version&amp;rdquo;; inherit src; phases = &amp;ldquo;installPhase&amp;rdquo;;
installPhase = &amp;rsquo;' set -x s=&amp;quot;$(&amp;lt; &amp;ldquo;$src/Makefile&amp;rdquo;)&amp;quot; get() { awk &amp;ldquo;/^$1 = / &amp;ldquo;&amp;rsquo;{print $3}&amp;rsquo; &amp;laquo;&amp;lt; &amp;ldquo;\(s&amp;rdquo; } printf &amp;lsquo;%s.</description></item><item><title>linux scheduling optimization</title><link>https://wiki.cont.run/linux-scheduling-optimization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/linux-scheduling-optimization/</guid><description>controlling scheduling policy with cgroup CFS Scheduler CFS Bandwidth Control hooking into scheduling decisions with bpf Controlling the CPU scheduler with BPF moving scheduling to userspace ghOSt: Fast &amp;amp; Flexible User-Space Delegation of Linux Scheduling fixing existing scheduling algorithm bugs Fixing SCHED_IDLE The Linux Scheduler: a Decade of Wasted Cores creating new scheduling algorithms Energy Aware Scheduling Scheduling for Android devices</description></item><item><title>lowering async await in rust</title><link>https://wiki.cont.run/lowering-async-await-in-rust/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/lowering-async-await-in-rust/</guid><description>We have a simple program (playground link) built with rust&amp;rsquo;s async/await feature.
usetokio::time::{sleep,Duration};#[tokio::main]asyncfn main(){sleep(Duration::from_secs(1)).await;}We want to understand all the magic rust compiler did to make this come to life. Here are a few references:
generators - The Rust Unstable Book 2033-experimental-coroutines - The Rust RFC Book 2394-async_await - The Rust RFC Book Stackless coroutines Generator support Asynchronous Programming in Rust Below (adapted from here) is roughly how rust compiler compiles the rust source code into machine code.</description></item><item><title>quine in haskell</title><link>https://wiki.cont.run/quine-in-haskell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/quine-in-haskell/</guid><description>See How to make compressed file quines, step by step
#!/usr/bin/env stack &amp;ndash; stack &amp;ndash;resolver lts-15.01 script
module Main where
import Data.List (intercalate)
main :: IO () main = putStr $ (unlines prefix) + (getPrefixDef prefix) where getPrefixDef list = (&amp;quot; prefix =\n [\n &amp;ldquo;) + (intercalate &amp;ldquo;,\n &amp;quot; (map show list)) + &amp;ldquo;\n ]&amp;rdquo; prefix = [ &amp;ldquo;#!/usr/bin/env stack&amp;rdquo;, &amp;ldquo;&amp;ndash; stack &amp;ndash;resolver lts-15.01 script&amp;rdquo;, &amp;ldquo;&amp;rdquo;, &amp;ldquo;module Main where&amp;rdquo;, &amp;ldquo;&amp;rdquo;, &amp;ldquo;import Data.</description></item><item><title>self-hosted infrastructure</title><link>https://wiki.cont.run/self-hosted-infrastructure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/self-hosted-infrastructure/</guid><description>TLDR: I use tailscale/zerotier to establish a smallish mesh network. I use envoy (not anymore, I now use nginx) as an edge router to forward L4 traffic. I mainly provision and manage services with nix, docker and sops. When it is absolutely required, I use k3s to deploy Kubernetes services. Traefik is used for routing, and authelia is used for blocking unauthorized access. To multiplexing protocols with a single port, I use aioproxy.</description></item><item><title>self-hosted services</title><link>https://wiki.cont.run/self-hosted-services/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/self-hosted-services/</guid><description>TODO. For now, See self-hosted infrastructure.</description></item><item><title>sigma bullets</title><link>https://wiki.cont.run/sigma-bullets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/sigma-bullets/</guid><description>Introduction This document summarize how a zero-knowledge confidential transaction scheme works and how to implement it. A confidential transaction scheme is a transaction scheme with which the transaction value and the balance of the sender and receiver are encrypted. The zero-knowledge part means that outsider can effectively learn nothing about the values, although he can verify the transaction is not fabricated. The main references are Bulletproofs and Zether. We use Zether to homomorphically encrypt the transaction value so that the we can directly add/subtract ciphertext of the encrypted balance which can then be decrypted into the correct balance after the transaction.</description></item><item><title>zero config proxies</title><link>https://wiki.cont.run/zero-config-proxies/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wiki.cont.run/zero-config-proxies/</guid><description>In most cases, we can export http_proxy=http://localhost:8081. But at times, programs do not recognize the environment variable http_proxy. We may need to refer to their manual to learn how to configure its proxy settings. It is tedious. For example, the way to specify proxy of git over HTTPS different from that of git over SSH. We need some non-intrusive (transparent) way to specify proxies. Applications are required of nothing. No configuration entry for proxies, no environment variable.</description></item></channel></rss>